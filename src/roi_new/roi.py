from collections import defaultdict
from threading import RLock

from ..stack import const as stconst
from ..util import make_uid

class Roi:
    """Base class for representing a region-of-interest (ROI).

    'group' is None or a group id (str).
    'labels' is None or a set of label ids (str).
    'params' is None or a reference to a RoiParameters object.
    'par_individual' is a dict with individual parameters.
    'props' is None or a weakref to RoiProperties generated by the 'params'
    'color' is None or a string of a hex RGB color ('#rrggbb')
    """
    __slots__ = ('__lock', '__id', '__weakref__', '__name', '__group', '__labels', '__params', '__par_individual', '__props', '__visible', '__color')

    def __init__(self, name=None, group=None, labels=None, params=None, par_ind=None, color=None, visible=None):
        self.__lock = RLock()
        self.__id = make_uid(self)
        self.__name = name
        self.__group = group
        if labels:
            if isinstance(labels, str):
                self.__labels = {labels}
            else:
                self.__labels = {l for l in labels}
        else:
            self.__labels = None
        self.__params = params
        self.__par_individual = par_ind
        self.__color = color
        self.__visible = visible

    @property
    def lock(self):
        return self.__lock

    @property
    def id(self):
        return self.__id

    @property
    def name(self):
        with self.__lock:
            return self.__name

    @name.setter
    def name(self, new):
        with self.__lock:
            if new:
                self.__name = new
            else:
                self.__name = None

    @property
    def group(self):
        with self.__lock:
            return self.group

    @group.setter
    def group(self, new):
        if not new:
            new = None
        with self.__lock:
            self.__group = new

    @property
    def labels(self):
        with self.__lock:
            if not self.__labels:
                return set()
            else:
                return self.__labels.copy()

    @labels.setter
    def labels(self, labels):
        with self.__lock:
            if not labels:
                self.__labels = None
            elif isinstance(labels, str):
                self.__labels = {labels}
            else:
                self.__labels = {l for l in labels}

    def add_labels(self, *labels):
        with self.__lock:
            if self.__labels:
                self.__labels.update(labels)
            else:
                self.__labels = {*labels}

    def drop_labels(self, *labels):
        with self.__lock:
            if self.__labels:
                self.__labels.difference_update(labels)
                if not self.__labels:
                    self.__labels = None

    #TODO: parameters


    @property
    def color(self):
        with self.__lock:
            return self.__color

    @color.setter
    def color(self, col):
        with self.__lock:
            self.__color = col

    @property
    def visible(self):
        with self.__lock:
            return self.__visible

    @visible.setter
    def visible(self, is_visible):
        with self.__lock:
            self.__visible = is_visible





## OLD STUFF:


class Roi(BaseRoi):
    __slots__ = ('_dimensions', '_rois')

    def __init__(self, dimensions, rois=None, **kwargs):
        super().__init__(**kwargs)
        self._dimensions = {d for d in dimensions if d in stconst.STACK_DIM}
        self._rois = {d: defaultdict(set) for d in self._dimensions}

    def at(self, t=None, z=None, c=None):
        """Get ROI at given stack position"""
        raise NotImplementedError #TODO
        res = None
        with self.lock:
            for dim in self._dimensions:
                r = self._rois[dim][None]
                if dim == stconst.T:
                    d = t
                elif dim == stconst.C:
                    d = c
                elif dim == stconst.Z:
                    d = z

                if d is not None:
                    r |= self._rois[dim][d]

                if res is None:
                    res = r
                else:
                    res &= r

        assert len(res) == 1 #TODO: More advanced processing?

        reutrn res.pop()





    def add(self, *rois):
        with self._lock:
            for roi in rois:
                for d in self._dimensions:
                    try:
                        self._dimensions[d][roi.position[d]].add(roi)
                    except:
                        self._dimensions[d][None].add(roi)
